---
title: 了解JAVA线程池
date: 2018-08-14 21:07:18
tags:
---
# 为什么要使用线程池
1. 创建/销毁线程需要系统开销，过于频繁的创建/销毁线程，会影响效率。
2. 线程并发数量过多，抢占资源而导致系统资源不足阻塞。
3. 管理线程，对线程制定一些策略。
所以我们要用线程池来缓存线程，减少系统开销，控制并发线程数量。

# 线程池之ThreadPoolExecutor概述
java的线程池支持主要通过ThreadPoolExecutor来实现。  
四大线程池FixedThreadPool，SingledThreadPool，CachedThreadPool，ScheduledThreadExecutor都是ThreadPoolExecutor的工厂类，只是参数不同。  
类继承关系：  
ExecutorService——>AbstractExecutorService——>ThreadPoolExecutor  
ExecutorService是ThreadPoolExecutor的顶层接口，使用线程池中的线程提交每个提交的任务。一般我们使用Executors的工厂方法比如Executors.newSingledThreadExecutor来创建ExecutorService。
## ThreadPoolExecutor核心参数
* <font color="#ff502c">corePoolSize</font>核心线程池数量
* <font color="#ff502c">maximumPoolSize</font>最大线程池数量
* <font color="#ff502c">keepAliveTime</font>线程空闲后存活时间，<font color="#ff502c">unit</font>时间单位
* <font color="#ff502c">workQueue</font>存放任务的阻塞队列
* <font color="#ff502c">handler</font>最大线程池和阻塞队列都满了以后的处理策略

### 线程状态
![2018-08-14.17.16.08-线程状态切换.png](https://raw.githubusercontent.com/needal/notes/master/img/2018-08-14.17.16.08-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.png)
* **新建**  
线程在被new实例化出来以后，就处于新建状态。
* **就绪**    
线程执行start()以后，该线程处于就绪状态，并不说明该线程立即执行。
* **运行**  
当就绪的线程获取被cpu调度获取cpu时间时，该线程进入运行状态，执行线程的任务。
* **阻塞**  
当运行中的线程进行IO操作获取数据或者进入同步代码块尝试获取其他锁，该线程进入阻塞状态，此时该线程释放cpu时间，但仍拥有原先锁，当阻塞结束时，该线程重新进入运行状态，而不会进入就绪态。
* **睡眠**  
线程执行Thread.sleep()以后，线程进入睡眠状态，释放拥有的cpu时间，但不释放拥有的锁，睡眠的时间结束后，进入就绪状态重新竞争cpu时间。 
* **等待**  
拥有的对象锁调用了Object.wait()或者ThreadB.join()后，线程进入等待状态。如果调用的是Object.wait()，线程会释放拥有的cpu时间和锁，当时间结束或Object.notify()后进入就绪状态。如果调用的是ThreadB.join()，当前线程会获取ThreadB的对象锁，而不会释放原先的对象锁，当线程B执行完毕时，当前线程才会进入就绪状态。
* **退出**   
线程正常执行完毕或者被IO阻塞的线程IO异常关闭后，线程进入退出状态，即结束状态。

### 线程池状态
![2018-08-14.19.34.40-线程池状态切换.jpg](https://raw.githubusercontent.com/needal/notes/master/img/2018-08-14.19.34.40-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E5%88%87%E6%8D%A2.jpg)
* **RUNNING**  
运行态，可处理新任务并执行队列中的任务  
* **SHUTDOWN**  
关闭态，调用shutDown方法后，不接受新任务，但处理队列中的任务  
* **STOP**  
停止态，调用shutDownNow方法后,不接受新任务，不处理队列中任务，且打断运行中任务  
* **TIDYING**  
整理态，所有任务已经结束，在调用shutdown()/shuntdownNow()中都会尝试更新为此状态。当workerCount = 0 ，将执行terminated()方法  
* **TERMINATED**  
结束态，terminated() 方法已完成  
当在execute(Runnable)方法中提交新任务时，且正在运行的线程数小于corePoolSize，即使其他工作线程处于空闲状态，也会创建一个新线程来出来该请求。如果正在运行的线程数大于corePoolSize但小于maximumPoolSize，则会把新线程优先使用corePoolSize中空闲的线程，如果corePoolSize中没有空闲的，那就放到一个阻塞队列中，当阻塞队列满时才会创建新的线程；如果corePoolSize中的线程又空闲了就会复用线程。如果正在运行的线程池数大于等于maximumPoolSize，则新线程会被拒绝。

# 线程池的配置
线程池并不是越大越好，也不是越小越好，需要根据实际情况得出最佳配置。
通常我们是根据任务执行的性质来确定线程池的大小。
* IO密集型任务：线程并不是一直在运行，而是被IO阻塞，所以可以多配置线程。**一般为CPU个数*2**。
* CPU密集型任务：大量复杂的运行，而CPU一般是2或4核较小，所以线程多了也无法获取CPU时间，反而占用了内存。**一般与CPU个数相同**。

# 线程池的关闭
executorService有两个关闭的方法，shutdown和shutdownNow，**区别主要是状态改变的不同**。  
shutdown方法后，ThreadPoolExecutor会变成SHUTDOWN状态，不接受新任务，但还要等待处理队列中的任务。类似于tcp协议的单向关闭。  
shutdownNow方法后，ThreadPoolExecutor会变成STOP状态，不接受新任务，不处理队列中的任务，对执行中的任务执行中断，但若执行中的线程未处理中断，则仍继续执行，所以shutdownNow方法后并不代表立刻关闭。  
仅仅执行shutdown/shutdownNow方法是不够的，执行完以后还需额外执行awaitTermination 方法，用于控制shutdown/shutdownNow以后等待的时间，防止任务无限期运行，因为shutdown/shutdownNow不能保证线程一定停止。